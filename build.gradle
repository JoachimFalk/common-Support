// vim: set syntax=groovy sts=2 ts=8 et:

/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'falk' at '09.01.15 18:34' with Gradle 2.2.1
 *
 * This generated file contains a commented-out sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at http://gradle.org/docs/2.2.1/userguide/tutorial_java_projects.html
 */

/*
// Apply the java plugin to add support for Java
apply plugin: 'java'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// In this section you declare the dependencies for your production and test code
dependencies {
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.7'

    // Declare the dependency for your favourite test framework you want to use in your tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile "junit:junit:4.11"
}
*/

import de.jfalk.gradle.JFHelperFunctions;

apply plugin: 'de.jfalk.gradle.cpp'
apply plugin: JFHelperFunctions;

//apply plugin: 'cpp' // replaced by JFCppPlugin 
apply plugin: 'visual-studio'
//apply plugin: 'eclipse'
//apply plugin: 'eclipse-cdt' <= This does not really work at the moment

// Here, ``this'' is the current org.gradle.api.Project
this.buildDir = 'obj'

//task hello {
//  doLast {
//    println 'Hello world!'
//  }
//}
//
//def x = "y"
//
//def flummyTestFun(String msg) {
//  println "I am flummy test function with msg: "  + msg
//}
//
//task flummy { myTask ->
//  def a = "b"
//
////analysis("in flummy this", this) // This is the containing class of this closure, i.e., the current project.
////analysis("in flummy myTask", myTask)
//  println '==== START ===='
////this.binding.variables.each {k,v -> println "$k = $v"}
//  binding.variables.each {k,v -> println "$k"}
//  println '===== END ====='
//  println "x = $x"
//  println "a = $a"
//  flummyTestFun "the test message"
//  println rootProject.buildDir
//  println rootProject.childProjects.get('PrebuiltLibraries').buildDir
//}
//
//task dumpTasks << {
//  def allTasks = project.getAllTasks(true)
//  allTasks[project].each { task ->
////  println task.toString() + " of " + task.class
//    analysis(task.toString(), task)
//  }
//}

//task build(dependsOn: 'assemble') {
//    doLast {
//        println 'Build done!'
//    }
//}

//task dumpTasks << {
//  def allTasks = project.getAllTasks(true)
//  allTasks[project].each { task ->
////  println task.toString() + " of " + task.class
//    analysis(task.toString(), task)
//  }
//}

def cosupportAllLibs = [
    "cosupport-allocators",
    "cosupport-base",
    "cosupport-initializer",
    "cosupport-math",
    "cosupport-path",
    "cosupport-random",
    "cosupport-smartptr",
    "cosupport-streams",
    "cosupport-string",
    "cosupport-systemc",
    "cosupport-tracing",
    "cosupport-xerces"
  ];

task VisualStudio(
    dependsOn:
      cosupportAllLibs.collect { it + "VisualStudio" } +
      "cosupportVisualStudio"
  ) {
  doFirst {
    println 'Creating VisualStudio solution files!'
  }
  doLast {
    println 'Created VisualStudio solution files!'
  }
}

import java.util.regex.Matcher 

class WrapXSDandDTDFiles extends DefaultTask {
  @InputFiles      FileCollection srcXSDandDTDFiles
  @OutputDirectory File           headerDir
  @OutputDirectory File           sourceDir

  @TaskAction
  void processIdlFiles() {
    srcXSDandDTDFiles.files.each { File f ->
      def m = f.name =~ /^(.*)\.(xsd|dtd)$/
      assert m instanceof Matcher
      assert m
//    println m.group(1) + ":" + m.group(2)
      File output = new File(headerDir, m.group(1)+"-"+m.group(2)+".c");
      output.text = '';
      if (m.group(2) == 'xsd') {
        output.append("static char const "+m.group(1)+"XSD[] =\n");
      } else {
        output.append("static char const "+m.group(1)+"DTD[] =\n");
      }
      f.eachLine { line ->
        String quotedLine = line.replaceAll(/["\\]/) { c -> '\\'+c }
        output.append("  \""+quotedLine+"\\n\"\n")
      }
      output.append("  ;\n");
    }
  }
}

task genSourceTest(type: WrapXSDandDTDFiles) {
  description = "Wrap xsd and dtd files in testlog/xerces into c files for consumption by the test_xerces application."
  srcXSDandDTDFiles = project.fileTree("testlogs/xerces") {
    include 'test1.xsd'
    include 'test2.dtd'
//  include '*.dtd'
//  include '*.xsd'
  }
  headerDir = project.file("${buildDir}/src/test_xerces/headers")
  sourceDir = project.file("${buildDir}/src/test_xerces/cpp")
}

model {
  buildTypes {
    debug
    release
  }
  components {
//  hello(JFNativeLibrarySpec)
//  main(JFNativeExecutableSpec) {
//    sources {
//      cpp {
//        lib library: "hello"
//      }
//    }
//  }
//  main(JFNativeExecutableSpec) {
//    sources {
//      cpp.lib library: 'boost', linkage: 'api'
//      cpp.lib library: 'util', linkage: 'static'
//    }
//  }

    "cosupport-base"(JFNativeLibrarySpec) {
      sources {
//      cppx(JFCppSourceSet) {
        cpp {
          exportedHeaders {
            srcDirs "src/cosupport-base/headers"
            // FIXME: This is a hack, but the CoSupport::DataTypes::ArrayFifo class depends on
            // the CoSupport::Math::ModuloGroup class.
            srcDirs "src/cosupport-math/headers"
            // FIXME: This is a hack, but the CoSupport::DataTypes::*Facade classes depend on
            // the CoSupport::SmartPtr::RefCount class.
            srcDirs "src/cosupport-smartptr/headers"
          }
          lib project: ':PrebuiltLibraries', library: "boost_headers", exportHeaders: true
        }
      }
      binaries.withType(SharedLibraryBinarySpec) {
//      analysis("bin", it);
        sources {
          cpp(JFCppSourceSet) {
            exportedCompilerArgs.define "COSUPPORT_DLL_IMPORT"
          }
        }
//      flummy "-DFLUMMY"
      }
//    binaries.withType(StaticLibraryBinarySpec) {
//      analysis("bin", it);
//      flammy "-DFLAMMY"
//    }
    }
    "cosupport-initializer"(JFNativeLibrarySpec) {
      sources {
        cpp {
          source {
            srcDirs "src/cosupport-initializer/cpp"
            include "**/*.cpp"
//          exclude "**/.*.sw*"
          }
          exportedHeaders {
            srcDirs "src/cosupport-initializer/headers"
          }
          lib library: "cosupport-base", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "boost_system"
          lib project: ':PrebuiltLibraries', library: "boost_thread"
        }
      }
    }
    "cosupport-smartptr"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
        }
      }
    }
    "cosupport-xerces"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib library: "cosupport-initializer", exportHeaders: true
          lib library: "cosupport-string", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "xerces-c", exportHeaders: true
        }
      }
    }
    "cosupport-systemc"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib library: "cosupport-smartptr", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "systemc", exportHeaders: true
        }
      }
    }
    "cosupport-tracing"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "systemc", exportHeaders: true
        }
      }
    }
    "cosupport-streams"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib library: "cosupport-string"
          lib project: ':PrebuiltLibraries', library: "boost_iostreams"
          lib project: ':PrebuiltLibraries', library: "boost_system"
        }
      }
    }
    "cosupport-string"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "boost_regex"
        }
      }
    }
    "cosupport-math"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
        }
      }
    }
    "cosupport-random"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "boost_random"
        }
      }
    }
    "cosupport-allocators"(JFNativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base", exportHeaders: true
          lib library: "cosupport-math"
        }
      }
    }
    "cosupport-path"(JFNativeLibrarySpec) { // lib_ ->
//    analysis("lib_", lib_)
      sources { // src_ ->
//      analysis("src_", src_)
        cpp { // cpp_ ->
//        analysis("cpp_", cpp_)
          source {
            srcDirs "src/cosupport-path/cpp"
            include "**/*.cpp"
          }
          exportedHeaders {
            srcDirs "src/cosupport-path/headers"
          }
          lib library: "cosupport-base", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "boost_filesystem", exportHeaders: true
          lib project: ':PrebuiltLibraries', library: "boost_system", exportHeaders: true
        }
      }
    }
    "cosupport"(JFNativeLibrarySpec) {
      sources {
        cpp {
          cosupportAllLibs.each {
              lib library: it, exportHeaders: true
            }
        }
      }
    }
    "test_arrayfifo"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
        }
      }
    }
    "test_dbgstream"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-streams"
        }
      }
    }
    "test_event_and_list"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-systemc"
        }
      }
    }
    "test_event_or_list"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-systemc"
        }
      }
    }
    "test_nested_event_lists"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-systemc"
          lib library: "cosupport-streams"
        }
      }
    }
    "test_facade"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-smartptr"
          lib library: "cosupport-string"
        }
      }
    }
    "test_idpool"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-allocators"
        }
      }
    }
    "test_interval"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-math"
        }
      }
    }
    "test_list"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-streams"
          lib library: "cosupport-smartptr"
        }
      }
    }
    "test_maybevalue"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-smartptr"
        }
      }
    }
    "test_modulo"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-math"
        }
      }
    }
    "test_path"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-path"
        }
      }
    }
    "test_po"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-math"
          lib library: "cosupport-streams"
        }
      }
    }
    "test_projection"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-streams"
        }
      }
    }
    "test_set"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-streams"
          lib library: "cosupport-smartptr"
        }
      }
    }
    "test_stl_output_for_xxx"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-streams"
        }
      }
    }
    "test_typename"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-string"
        }
      }
    }
    "test_value"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-smartptr"
        }
      }
    }
    "test_vector"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-streams"
          lib library: "cosupport-smartptr"
        }
      }
    }
    "test_xerces"(JFNativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-xerces"
          lib library: "cosupport-streams"
          lib project: ':PrebuiltLibraries', library: "boost_filesystem"
          lib project: ':PrebuiltLibraries', library: "boost_system"
        }
        cpp {
          generatedBy tasks.genSourceTest
        }
      }
    }
  }
  binaries {
    all {
//    analysis("binary", it)
//    println "TOOLCHAIN: " + toolChain
      // Specify toolchain-agnostic stuff
      if (buildType.name == 'release') {
        cppCompiler.define "NDEBUG"
      }
      // Define toolchain-specific compiler and linker options
      if (toolChain in VisualCpp) {
        // Enable standard C++ exception for visual studio
        cppCompiler.args "/EHsc" //, '/I"C:/Program Files (x86)/Windows Kits/10/Include/10.0.10586.0/ucrt/"'
        linker.args "/LIBPATH:" + rootProject.childProjects.get('PrebuiltLibraries').projectDir + "\\i686-msvc120-win\\libboost-1_55\\lib"
        if (buildType.name == 'debug') {
          cppCompiler.args "/Z7", "/MDd"
          linker.args "/DEBUG"
        } else {
          cppCompiler.args "/MD"
        }
      } else if (toolChain in Gcc) {
        cppCompiler.args "-Wall", "-std=gnu++11"
        cCompiler.args "-Wall", "-std=gnu99"
        linker.args "-Xlinker", "-S"
        if (buildType.name == 'debug') {
          cppCompiler.args "-ggdb"
          cCompiler.args "-ggdb"
        } else {
          cppCompiler.args "-O2"
          cCompiler.args "-O2"
        }
      }
    }
    // For any shared library binaries built with Visual C++, define the DLL_EXPORT macro.
    withType(SharedLibraryBinarySpec) {
      if (toolChain in VisualCpp) {
        def dllExportDefine = it.component.name.toUpperCase().inject("") {
            result, c -> c >= 'A' && c <= 'Z' ? result + c : result + '_'
          } + "_DLL_EXPORT"
  //    println "FLUMMY: " + dllExportDefine
        cppCompiler.define dllExportDefine
      }
    }
    // For any executable built with Visual C++, use the console subsystem of windows!
    withType(NativeExecutableBinarySpec) {
      if (toolChain in VisualCpp) {
        linker.args "/SUBSYSTEM:CONSOLE"
      }
    }
  }
}

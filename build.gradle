// vim: set syntax=groovy sts=2 ts=8 et:

/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'falk' at '09.01.15 18:34' with Gradle 2.2.1
 *
 * This generated file contains a commented-out sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at http://gradle.org/docs/2.2.1/userguide/tutorial_java_projects.html
 */

/*
// Apply the java plugin to add support for Java
apply plugin: 'java'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// In this section you declare the dependencies for your production and test code
dependencies {
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.7'

    // Declare the dependency for your favourite test framework you want to use in your tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile "junit:junit:4.11"
}
*/

apply plugin: 'cpp'
apply plugin: 'native-component'
apply plugin: 'eclipse'
//apply plugin: 'eclipse-cdt' <= This does not really work at the moment

def analysis(String prefix, Object obj) {
  println "================================================================================"
  println prefix+": " + obj 
  try {
    obj.properties.sort().each  { prop, val ->
      println prefix+"."+prop+": " + val
    //if(prop in ["metaClass","class"]) return
    //if(f.hasProperty(prop)) f[prop] = val
    }
  } catch (all) {
    println all
  }
  try {
    obj.metaClass.methods.sort { it.name }.each { method ->
  //  println prefix+"."+method.name+" of type "+method.descriptor
      println prefix+"."+method.signature
    }
  } catch (all) {
    println all
  }
  println "================================================================================"
}

// this is a project
this.buildDir = 'obj'

//task hello {
//  doLast {
//    println 'Hello world!'
//  }
//}
//
//def x = "y"
//
//def flummyTestFun(String msg) {
//  println "I am flummy test function with msg: "  + msg
//}
//
//task flummy { myTask ->
//  def a = "b"
//
////analysis("in flummy this", this) // This is the containing class of this closure, i.e., the current project.
////analysis("in flummy myTask", myTask)
//  println '==== START ===='
////this.binding.variables.each {k,v -> println "$k = $v"}
//  binding.variables.each {k,v -> println "$k"}
//  println '===== END ====='
//  println "x = $x"
//  println "a = $a"
//  flummyTestFun "the test message"
//  println rootProject.buildDir
//  println rootProject.childProjects.get('PrebuiltLibraries').buildDir
//}
//
//task dumpTasks << {
//  def allTasks = project.getAllTasks(true)
//  allTasks[project].each { task ->
////  println task.toString() + " of " + task.class
//    analysis(task.toString(), task)
//  }
//}

//task build(dependsOn: 'assemble') {
//    doLast {
//        println 'Build done!'
//    }
//}

apply plugin: 'visual-studio'

//task dumpTasks << {
//  def allTasks = project.getAllTasks(true)
//  allTasks[project].each { task ->
////  println task.toString() + " of " + task.class
//    analysis(task.toString(), task)
//  }
//}

task VisualStudio(dependsOn: [
  "cosupport-allocatorsVisualStudio",
  "cosupport-baseVisualStudio",
  "cosupport-initializerVisualStudio",
  "cosupport-mathVisualStudio",
  "cosupport-pathVisualStudio",
  "cosupport-randomVisualStudio",
  "cosupport-smartptrVisualStudio",
  "cosupport-streamsVisualStudio",
  "cosupport-stringVisualStudio",
  "cosupport-systemcVisualStudio",
  "cosupport-xercesVisualStudio"]) {
  doFirst {
    println 'Creating VisualStudio solution files!'
  }
  doLast {
    println 'Created VisualStudio solution files!'
  }
}

model {
  components {
//  hello(NativeLibrarySpec)
//  main(NativeExecutableSpec) {
//    sources {
//      cpp {
//        lib library: "hello"
//      }
//    }
//  }
//  main(NativeExecutableSpec) {
//    sources {
//      cpp.lib library: 'boost', linkage: 'api'
//      cpp.lib library: 'util', linkage: 'static'
//    }
//  }

    "cosupport-base"(NativeLibrarySpec)
    "cosupport-initializer"(NativeLibrarySpec) {
      sources {
        cpp {
          source {
            srcDirs "src/cosupport-initializer/cpp"
            include "**/*.cpp"
          }
          exportedHeaders {
            srcDirs "src/cosupport-initializer/headers"
          }

          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_system"
          lib project: ':PrebuiltLibraries', library: "boost_thread"
        }
      }
    }
    "cosupport-smartptr"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_headers"
        }
      }
    }
    "cosupport-xerces"(NativeLibrarySpec) {
      sources {
	    cpp {
		//	source {
		//		srcDirs "C:/Program Files (x86)/Windows Kits/10/Include/10.0.10586.0/ucrt/"
		//		//include "**/*.cpp"
		//	}
		  //lib library: "C:/Program Files (x86)/Windows Kits/10/Lib/10.0.10586.0/ucrt/x64/ucrt"
      
          lib library: "cosupport-base"
          lib library: "cosupport-initializer"
          lib library: "cosupport-string"
        }
      }
    }
    "cosupport-systemc"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
        }
      }
    }
    "cosupport-streams"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-string"
          lib project: ':PrebuiltLibraries', library: "boost_iostreams"
          lib project: ':PrebuiltLibraries', library: "boost_system"
        }
      }
    }
    "cosupport-string"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_regex"
        }
      }
    }
    "cosupport-math"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
        }
      }
    }
    "cosupport-random"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_random"
        }
      }
    }
    "cosupport-allocators"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-math"
        }
      }
    }
    "cosupport-path"(NativeLibrarySpec) { // lib_ ->
//    analysis("lib_", lib_)
      sources { // src_ ->
//      analysis("src_", src_)
        cpp { // cpp_ ->
//        analysis("cpp_", cpp_)
          source {
            srcDirs "src/cosupport-path/cpp"
            include "**/*.cpp"
          }
          exportedHeaders {
            srcDirs "src/cosupport-path/headers"
          }
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_filesystem"
        }
      }
    }
    "test_dbgstream"(NativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-streams"
          lib library: "cosupport-string"
        }
      }
    }
  }
  binaries {
    all {
      // Define a preprocessor macro for every binary
      cppCompiler.define "NDEBUG"

  //  println "TOOLCHAIN: " + toolChain

      // Define toolchain-specific compiler and linker options
      if (toolChain in Gcc) {
          cppCompiler.args "-O2", "-std=gnu++11"
  //      cCompiler.args "-O2", "-std=gnu99"
          linker.args "-Xlinker", "-S"
      }
      if (toolChain in VisualCpp) {
          cppCompiler.args "/Z7", "/EHsc", '/I"C:/Program Files (x86)/Windows Kits/10/Include/10.0.10586.0/ucrt/"'
          linker.args "/DEBUG", "/LIBPATH:" + rootProject.childProjects.get('PrebuiltLibraries').projectDir + "\\x86_64-msvc120-win\\lib"
      }
    }
    // For any shared library binaries built with Visual C++, define the DLL_EXPORT macro
    withType(SharedLibraryBinarySpec) {
      if (toolChain in VisualCpp) {
          cppCompiler.define "DLL_EXPORT"
      }
    }
  }
}

// vim: set syntax=groovy sts=2 ts=8 et:

/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'falk' at '09.01.15 18:34' with Gradle 2.2.1
 *
 * This generated file contains a commented-out sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at http://gradle.org/docs/2.2.1/userguide/tutorial_java_projects.html
 */

/*
// Apply the java plugin to add support for Java
apply plugin: 'java'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// In this section you declare the dependencies for your production and test code
dependencies {
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.7'

    // Declare the dependency for your favourite test framework you want to use in your tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile "junit:junit:4.11"
}
*/

apply plugin: 'cpp'
apply plugin: 'native-component'
apply plugin: 'eclipse'
//apply plugin: 'eclipse-cdt'
apply plugin: 'visual-studio'

def analysis(String prefix, Object obj) {
  println prefix+": " + obj 
  try {
    obj.properties.sort().each  { prop, val ->
      println prefix+"."+prop+": " + val
    //if(prop in ["metaClass","class"]) return
    //if(f.hasProperty(prop)) f[prop] = val
    }
  } catch (all) {
    println all
  }
  try {
    obj.metaClass.methods.each { method ->
  //  println prefix+"."+method.name+" of type "+method.descriptor
      println prefix+"."+method.signature
    }
  } catch (all) {
    println all
  }
}

// this is a project
this.buildDir = 'obj'

task hello {
  doLast {
    println 'Hello world!'
  }
}

def x = "y"

def flummyTestFun(String msg) {
  println "I am flummy test function with msg: "  + msg
}

task flummy { myTask ->
  def a = "b"

//analysis("in flummy this", this) // This is the containing class of this closure, i.e., the current project.
//analysis("in flummy myTask", myTask)
  println '==== START ===='
//this.binding.variables.each {k,v -> println "$k = $v"}
  binding.variables.each {k,v -> println "$k"}
  println '===== END ====='
  println "x = $x"
  println "a = $a"
  flummyTestFun "the test message"
  println rootProject.buildDir
  println rootProject.childProjects.get('PrebuiltLibraries').buildDir
}

task dumpTasks << {
  def allTasks = project.getAllTasks(true)
  allTasks[project].each { task ->
//  println task.toString() + " of " + task.class
    analysis(task.toString(), task)
  }
}

task VisualStudio(dependsOn: [
  "cosupport-allocatorsVisualStudio",
  "cosupport-baseVisualStudio",
  "cosupport-initializerVisualStudio",
  "cosupport-mathVisualStudio",
  "cosupport-pathVisualStudio",
  "cosupport-randomVisualStudio",
  "cosupport-smartptrVisualStudio",
  "cosupport-streamsVisualStudio",
  "cosupport-stringVisualStudio",
  "cosupport-systemcVisualStudio",
  "cosupport-xercesVisualStudio"]) {
  doFirst {
    println 'Creating VisualStudio solution files!'
  }
  doLast {
    println 'Created VisualStudio solution files!'
  }
}

//task build(dependsOn: 'assemble') {
//    doLast {
//        println 'Build done!'
//    }
//}

model {

  /*
  components {
    main(NativeExecutableSpec) {
      sources {
          cpp.lib library: 'boost', linkage: 'api'
          cpp.lib library: 'util', linkage: 'static'
      }
    }
  }
   */

  components {
    "cosupport-base"(NativeLibrarySpec)
    "cosupport-initializer"(NativeLibrarySpec) {
      sources {
        cpp {
          source {
            srcDirs "src/cosupport-initializer/cpp"
            include "**/*.cpp"
          }
          exportedHeaders {
            srcDirs "src/cosupport-initializer/headers"
          }

          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_system"
          lib project: ':PrebuiltLibraries', library: "boost_thread"
        }
      }
    }
    "cosupport-smartptr"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
        }
      }
    }
    "cosupport-xerces"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-initializer"
          lib library: "cosupport-string"
        }
      }
    }
    "cosupport-systemc"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
        }
      }
    }
    "cosupport-streams"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-string"
          lib project: ':PrebuiltLibraries', library: "boost_iostreams"
          lib project: ':PrebuiltLibraries', library: "boost_system"
        }
      }
    }
    "cosupport-string"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_regex"
        }
      }
    }
    "cosupport-math"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
        }
      }
    }
    "cosupport-random"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_random"
        }
      }
    }
    "cosupport-allocators"(NativeLibrarySpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-math"
        }
      }
    }
    "cosupport-path"(NativeLibrarySpec) { // lib_ ->
//    analysis("lib_", lib_)
      sources { // src_ ->
//      analysis("src_", src_)
        cpp { // cpp_ ->
//        analysis("cpp_", cpp_)
          source {
            srcDirs "src/cosupport-path/cpp"
            include "**/*.cpp"
          }
          exportedHeaders {
            srcDirs "src/cosupport-path/headers"
          }
          lib library: "cosupport-base"
          lib project: ':PrebuiltLibraries', library: "boost_filesystem"
        }
      }
    }
    "test_dbgstream"(NativeExecutableSpec) {
      sources {
        cpp {
          lib library: "cosupport-base"
          lib library: "cosupport-streams"
          lib library: "cosupport-string"
        }
      }
    }
  }
}

//model {
//    components {
//        hello(NativeLibrarySpec)
//        main(NativeExecutableSpec) {
//            sources {
//                cpp {
//                    lib library: "hello"
//                }
//            }
//        }
//    }
//}

binaries.all {
    // Define a preprocessor macro for every binary
    cppCompiler.define "NDEBUG"

//  println "TOOLCHAIN: " + toolChain

    // Define toolchain-specific compiler and linker options
    if (toolChain in Gcc) {
        cppCompiler.args "-O2", "-std=gnu++11"
//      cCompiler.args "-O2", "-std=gnu99"
        linker.args "-Xlinker", "-S"
    }
    if (toolChain in VisualCpp) {
        cppCompiler.args "/Zi", "/EHsc"
        linker.args "/DEBUG", "/LIBPATH:" + rootProject.childProjects.get('PrebuiltLibraries').projectDir + "\\x86_64-msvc120-win\\lib"
    }
}

// For any shared library binaries built with Visual C++, define the DLL_EXPORT macro
binaries.withType(SharedLibraryBinarySpec) {
    if (toolChain in VisualCpp) {
        cppCompiler.define "DLL_EXPORT"
    }
}
